{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, input, effect, Directive, computed, ChangeDetectionStrategy, Component, model, inject, DOCUMENT, NgModule } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { config, dom, icon, parse, counter, text } from '@fortawesome/fontawesome-svg-core';\nconst _c0 = [\"*\"];\nlet FaConfig = /*#__PURE__*/(() => {\n  class FaConfig {\n    /**\n     * Default prefix to use, when one is not provided with the icon name.\n     *\n     * @default 'fas'\n     */\n    defaultPrefix = 'fas';\n    /**\n     * Provides a fallback icon to use whilst main icon is being loaded asynchronously.\n     * When value is null, then fa-icon component will throw an error if icon input is missing.\n     * When value is not null, then the provided icon will be used as a fallback icon if icon input is missing.\n     *\n     * @default null\n     */\n    fallbackIcon = null;\n    /**\n     * Set icons to the same fixed width.\n     *\n     * @see {@link: https://fontawesome.com/how-to-use/on-the-web/styling/fixed-width-icons}\n     * @default false\n     */\n    fixedWidth;\n    /**\n     * Automatically add Font Awesome styles to the document when icon is rendered.\n     *\n     * For the majority of the cases the automatically added CSS is sufficient,\n     * please refer to the linked guide for more information on when to disable\n     * this feature.\n     *\n     * @see {@link: https://github.com/FortAwesome/angular-fontawesome/blob/main/docs/guide/adding-css.md}\n     * @default true\n     */\n    set autoAddCss(value) {\n      config.autoAddCss = value;\n      this._autoAddCss = value;\n    }\n    get autoAddCss() {\n      return this._autoAddCss;\n    }\n    _autoAddCss = true;\n    static ɵfac = function FaConfig_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaConfig)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: FaConfig,\n      factory: FaConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return FaConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaIconLibrary = /*#__PURE__*/(() => {\n  class FaIconLibrary {\n    definitions = {};\n    addIcons(...icons) {\n      for (const icon of icons) {\n        if (!(icon.prefix in this.definitions)) {\n          this.definitions[icon.prefix] = {};\n        }\n        this.definitions[icon.prefix][icon.iconName] = icon;\n        for (const alias of icon.icon[2]) {\n          if (typeof alias === 'string') {\n            this.definitions[icon.prefix][alias] = icon;\n          }\n        }\n      }\n    }\n    addIconPacks(...packs) {\n      for (const pack of packs) {\n        const icons = Object.keys(pack).map(key => pack[key]);\n        this.addIcons(...icons);\n      }\n    }\n    getIconDefinition(prefix, name) {\n      if (prefix in this.definitions && name in this.definitions[prefix]) {\n        return this.definitions[prefix][name];\n      }\n      return null;\n    }\n    static ɵfac = function FaIconLibrary_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaIconLibrary)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: FaIconLibrary,\n      factory: FaIconLibrary.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return FaIconLibrary;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst faWarnIfIconDefinitionMissing = iconSpec => {\n  throw new Error(`Could not find icon with iconName=${iconSpec.iconName} and prefix=${iconSpec.prefix} in the icon library.`);\n};\nconst faWarnIfIconSpecMissing = () => {\n  throw new Error('Property `icon` is required for `fa-icon`/`fa-duotone-icon` components.');\n};\nconst isKnownRotateValue = rotate => rotate != null && (rotate === 90 || rotate === 180 || rotate === 270 || rotate === '90' || rotate === '180' || rotate === '270');\n/**\n * Fontawesome class list.\n * Returns classes array by props.\n */\nconst faClassList = props => {\n  const knownRotateValue = isKnownRotateValue(props.rotate);\n  const classes = {\n    [`fa-${props.animation}`]: props.animation != null && !props.animation.startsWith('spin'),\n    'fa-spin': props.animation === 'spin' || props.animation === 'spin-reverse',\n    'fa-spin-pulse': props.animation === 'spin-pulse' || props.animation === 'spin-pulse-reverse',\n    'fa-spin-reverse': props.animation === 'spin-reverse' || props.animation === 'spin-pulse-reverse',\n    // According to https://fontawesome.com/docs/web/style/animate#spin fa-pulse\n    // class is deprecated, remove the below line when Font Awesome 5 support\n    // is dropped.\n    'fa-pulse': props.animation === 'spin-pulse' || props.animation === 'spin-pulse-reverse',\n    'fa-fw': props.fixedWidth,\n    'fa-border': props.border,\n    'fa-inverse': props.inverse,\n    'fa-layers-counter': props.counter,\n    'fa-flip-horizontal': props.flip === 'horizontal' || props.flip === 'both',\n    'fa-flip-vertical': props.flip === 'vertical' || props.flip === 'both',\n    [`fa-${props.size}`]: props.size !== null,\n    [`fa-rotate-${props.rotate}`]: knownRotateValue,\n    'fa-rotate-by': props.rotate != null && !knownRotateValue,\n    [`fa-pull-${props.pull}`]: props.pull !== null,\n    [`fa-stack-${props.stackItemSize}`]: props.stackItemSize != null\n  };\n  return Object.keys(classes).map(key => classes[key] ? key : null).filter(key => key != null);\n};\nconst cssInserted = new WeakSet();\nconst autoCssId = 'fa-auto-css';\n/**\n * Ensure that Font Awesome CSS is inserted into the page.\n *\n * SVG Core has the same logic to insert the same styles into the page, however\n * it's not aware of Angular SSR and therefore styles won't be added in that\n * context leading to https://github.com/FortAwesome/angular-fontawesome/issues/48.\n * That's why the same logic is duplicated here.\n *\n * @param document - Document.\n * @param config - Font Awesome configuration.\n */\nfunction ensureCss(document, config) {\n  if (!config.autoAddCss) {\n    return;\n  }\n  if (cssInserted.has(document)) {\n    return;\n  }\n  // Prevent adding the same styles again after hydration.\n  if (document.getElementById(autoCssId) != null) {\n    config.autoAddCss = false;\n    cssInserted.add(document);\n    return;\n  }\n  const style = document.createElement('style');\n  style.setAttribute('type', 'text/css');\n  style.setAttribute('id', autoCssId);\n  style.innerHTML = dom.css();\n  const headChildren = document.head.childNodes;\n  let beforeChild = null;\n  for (let i = headChildren.length - 1; i > -1; i--) {\n    const child = headChildren[i];\n    const tagName = child.nodeName.toUpperCase();\n    if (['STYLE', 'LINK'].indexOf(tagName) > -1) {\n      beforeChild = child;\n    }\n  }\n  document.head.insertBefore(style, beforeChild);\n  // Prevent SVG Core from adding the same styles.\n  //\n  // As the logic is present in two places and SVG Core is not aware about\n  // this library, it may lead to styles being added twice. This can only\n  // occur when icon is rendered by SVG Core before the Angular component\n  // and should not have any significant negative impact. This is a rare\n  // use case, and it's tricky to prevent, so we accept this behavior. Consumer\n  // can choose to disable `FaConfig.autoAddCss` and add styles manually to\n  // prevent this from happening.\n  config.autoAddCss = false;\n  cssInserted.add(document);\n}\n\n/**\n * Returns if is IconLookup or not.\n */\nconst isIconLookup = i => i.prefix !== undefined && i.iconName !== undefined;\n\n/**\n * Normalizing icon spec.\n */\nconst faNormalizeIconSpec = (iconSpec, defaultPrefix) => {\n  if (isIconLookup(iconSpec)) {\n    return iconSpec;\n  }\n  if (Array.isArray(iconSpec) && iconSpec.length === 2) {\n    return {\n      prefix: iconSpec[0],\n      iconName: iconSpec[1]\n    };\n  }\n  return {\n    prefix: defaultPrefix,\n    iconName: iconSpec\n  };\n};\nlet FaStackItemSizeDirective = /*#__PURE__*/(() => {\n  class FaStackItemSizeDirective {\n    /**\n     * Specify whether icon inside {@link FaStackComponent} should be rendered in\n     * regular size (1x) or as a larger icon (2x).\n     */\n    stackItemSize = input('1x');\n    /**\n     * @internal\n     */\n    size = input();\n    _effect = effect(() => {\n      const size = this.size();\n      if (size) {\n        throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. ' + 'Set size on the enclosing fa-stack instead: <fa-stack size=\"4x\">...</fa-stack>.');\n      }\n    });\n    static ɵfac = function FaStackItemSizeDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaStackItemSizeDirective)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: FaStackItemSizeDirective,\n      selectors: [[\"fa-icon\", \"stackItemSize\", \"\"], [\"fa-duotone-icon\", \"stackItemSize\", \"\"]],\n      inputs: {\n        stackItemSize: [1, \"stackItemSize\"],\n        size: [1, \"size\"]\n      }\n    });\n  }\n  return FaStackItemSizeDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaStackComponent = /*#__PURE__*/(() => {\n  class FaStackComponent {\n    /**\n     * Size of the stacked icon.\n     * Note that stacked icon is by default 2 times bigger, than non-stacked icon.\n     * You'll need to set size using custom CSS to align stacked icon with a\n     * simple one. E.g. `fa-stack { font-size: 0.5em; }`.\n     */\n    size = input();\n    classes = computed(() => {\n      const sizeValue = this.size();\n      const sizeClass = sizeValue ? {\n        [`fa-${sizeValue}`]: true\n      } : {};\n      return {\n        ...sizeClass,\n        'fa-stack': true\n      };\n    });\n    static ɵfac = function FaStackComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaStackComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaStackComponent,\n      selectors: [[\"fa-stack\"]],\n      hostVars: 2,\n      hostBindings: function FaStackComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassMap(ctx.classes());\n        }\n      },\n      inputs: {\n        size: [1, \"size\"]\n      },\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function FaStackComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaStackComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaIconComponent = /*#__PURE__*/(() => {\n  class FaIconComponent {\n    icon = model();\n    /**\n     * Specify a title for the icon.\n     *\n     * This text will be displayed in a tooltip on hover and presented to the\n     * screen readers.\n     */\n    title = model();\n    /**\n     * Icon animation.\n     *\n     * Most of the animations are only available when using Font Awesome 6. With\n     * Font Awesome 5, only 'spin' and 'spin-pulse' are supported.\n     */\n    animation = model();\n    mask = model();\n    flip = model();\n    size = model();\n    pull = model();\n    border = model();\n    inverse = model();\n    symbol = model();\n    rotate = model();\n    fixedWidth = model();\n    transform = model();\n    /**\n     * Specify the `role` attribute for the rendered <svg> element.\n     *\n     * @default 'img'\n     */\n    a11yRole = model();\n    renderedIconHTML = computed(() => {\n      const iconValue = this.icon() ?? this.config.fallbackIcon;\n      if (!iconValue) {\n        faWarnIfIconSpecMissing();\n        return '';\n      }\n      const iconDefinition = this.findIconDefinition(iconValue);\n      if (!iconDefinition) {\n        return '';\n      }\n      const params = this.buildParams();\n      ensureCss(this.document, this.config);\n      const renderedIcon = icon(iconDefinition, params);\n      return this.sanitizer.bypassSecurityTrustHtml(renderedIcon.html.join('\\n'));\n    });\n    document = inject(DOCUMENT);\n    sanitizer = inject(DomSanitizer);\n    config = inject(FaConfig);\n    iconLibrary = inject(FaIconLibrary);\n    stackItem = inject(FaStackItemSizeDirective, {\n      optional: true\n    });\n    stack = inject(FaStackComponent, {\n      optional: true\n    });\n    constructor() {\n      if (this.stack != null && this.stackItem == null) {\n        console.error('FontAwesome: fa-icon and fa-duotone-icon elements must specify stackItemSize attribute when wrapped into ' + 'fa-stack. Example: <fa-icon stackItemSize=\"2x\" />.');\n      }\n    }\n    findIconDefinition(i) {\n      const lookup = faNormalizeIconSpec(i, this.config.defaultPrefix);\n      if ('icon' in lookup) {\n        return lookup;\n      }\n      const definition = this.iconLibrary.getIconDefinition(lookup.prefix, lookup.iconName);\n      if (definition != null) {\n        return definition;\n      }\n      faWarnIfIconDefinitionMissing(lookup);\n      return null;\n    }\n    buildParams() {\n      const fixedWidth = this.fixedWidth();\n      const classOpts = {\n        flip: this.flip(),\n        animation: this.animation(),\n        border: this.border(),\n        inverse: this.inverse(),\n        size: this.size(),\n        pull: this.pull(),\n        rotate: this.rotate(),\n        fixedWidth: typeof fixedWidth === 'boolean' ? fixedWidth : this.config.fixedWidth,\n        stackItemSize: this.stackItem != null ? this.stackItem.stackItemSize() : undefined\n      };\n      const transform = this.transform();\n      const parsedTransform = typeof transform === 'string' ? parse.transform(transform) : transform;\n      const mask = this.mask();\n      const maskIconDefinition = mask != null ? this.findIconDefinition(mask) : null;\n      const attributes = {};\n      const a11yRole = this.a11yRole();\n      if (a11yRole != null) {\n        attributes['role'] = a11yRole;\n      }\n      const styles = {};\n      if (classOpts.rotate != null && !isKnownRotateValue(classOpts.rotate)) {\n        styles['--fa-rotate-angle'] = `${classOpts.rotate}`;\n      }\n      return {\n        title: this.title(),\n        transform: parsedTransform,\n        classes: faClassList(classOpts),\n        mask: maskIconDefinition ?? undefined,\n        symbol: this.symbol(),\n        attributes,\n        styles\n      };\n    }\n    static ɵfac = function FaIconComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaIconComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaIconComponent,\n      selectors: [[\"fa-icon\"]],\n      hostAttrs: [1, \"ng-fa-icon\"],\n      hostVars: 2,\n      hostBindings: function FaIconComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"innerHTML\", ctx.renderedIconHTML(), i0.ɵɵsanitizeHtml);\n          i0.ɵɵattribute(\"title\", ctx.title() ?? undefined);\n        }\n      },\n      inputs: {\n        icon: [1, \"icon\"],\n        title: [1, \"title\"],\n        animation: [1, \"animation\"],\n        mask: [1, \"mask\"],\n        flip: [1, \"flip\"],\n        size: [1, \"size\"],\n        pull: [1, \"pull\"],\n        border: [1, \"border\"],\n        inverse: [1, \"inverse\"],\n        symbol: [1, \"symbol\"],\n        rotate: [1, \"rotate\"],\n        fixedWidth: [1, \"fixedWidth\"],\n        transform: [1, \"transform\"],\n        a11yRole: [1, \"a11yRole\"]\n      },\n      outputs: {\n        icon: \"iconChange\",\n        title: \"titleChange\",\n        animation: \"animationChange\",\n        mask: \"maskChange\",\n        flip: \"flipChange\",\n        size: \"sizeChange\",\n        pull: \"pullChange\",\n        border: \"borderChange\",\n        inverse: \"inverseChange\",\n        symbol: \"symbolChange\",\n        rotate: \"rotateChange\",\n        fixedWidth: \"fixedWidthChange\",\n        transform: \"transformChange\",\n        a11yRole: \"a11yRoleChange\"\n      },\n      decls: 0,\n      vars: 0,\n      template: function FaIconComponent_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaIconComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaDuotoneIconComponent = /*#__PURE__*/(() => {\n  class FaDuotoneIconComponent extends FaIconComponent {\n    /**\n     * Swap the default opacity of each duotone icon’s layers. This will make an\n     * icon’s primary layer have the default opacity of 40% rather than its\n     * secondary layer.\n     *\n     * @default false\n     */\n    swapOpacity = input();\n    /**\n     * Customize the opacity of the primary icon layer.\n     * Valid values are in range [0, 1.0].\n     *\n     * @default 1.0\n     */\n    primaryOpacity = input();\n    /**\n     * Customize the opacity of the secondary icon layer.\n     * Valid values are in range [0, 1.0].\n     *\n     * @default 0.4\n     */\n    secondaryOpacity = input();\n    /**\n     * Customize the color of the primary icon layer.\n     * Accepts any valid CSS color value.\n     *\n     * @default CSS inherited color\n     */\n    primaryColor = input();\n    /**\n     * Customize the color of the secondary icon layer.\n     * Accepts any valid CSS color value.\n     *\n     * @default CSS inherited color\n     */\n    secondaryColor = input();\n    findIconDefinition(i) {\n      const definition = super.findIconDefinition(i);\n      if (definition != null && !Array.isArray(definition.icon[4])) {\n        throw new Error('The specified icon does not appear to be a Duotone icon. ' + 'Check that you specified the correct style: ' + `<fa-duotone-icon [icon]=\"['fad', '${definition.iconName}']\" /> ` + `or use: <fa-icon icon=\"${definition.iconName}\" /> instead.`);\n      }\n      return definition;\n    }\n    buildParams() {\n      const params = super.buildParams();\n      const swapOpacity = this.swapOpacity();\n      if (swapOpacity === true || swapOpacity === 'true') {\n        if (Array.isArray(params.classes)) {\n          params.classes.push('fa-swap-opacity');\n        } else if (typeof params.classes === 'string') {\n          params.classes = [params.classes, 'fa-swap-opacity'];\n        } else {\n          params.classes = ['fa-swap-opacity'];\n        }\n      }\n      if (params.styles == null) {\n        params.styles = {};\n      }\n      const primaryOpacity = this.primaryOpacity();\n      if (primaryOpacity != null) {\n        params.styles['--fa-primary-opacity'] = primaryOpacity.toString();\n      }\n      const secondaryOpacity = this.secondaryOpacity();\n      if (secondaryOpacity != null) {\n        params.styles['--fa-secondary-opacity'] = secondaryOpacity.toString();\n      }\n      const primaryColor = this.primaryColor();\n      if (primaryColor != null) {\n        params.styles['--fa-primary-color'] = primaryColor;\n      }\n      const secondaryColor = this.secondaryColor();\n      if (secondaryColor != null) {\n        params.styles['--fa-secondary-color'] = secondaryColor;\n      }\n      return params;\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵFaDuotoneIconComponent_BaseFactory;\n      return function FaDuotoneIconComponent_Factory(__ngFactoryType__) {\n        return (ɵFaDuotoneIconComponent_BaseFactory || (ɵFaDuotoneIconComponent_BaseFactory = i0.ɵɵgetInheritedFactory(FaDuotoneIconComponent)))(__ngFactoryType__ || FaDuotoneIconComponent);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaDuotoneIconComponent,\n      selectors: [[\"fa-duotone-icon\"]],\n      inputs: {\n        swapOpacity: [1, \"swapOpacity\"],\n        primaryOpacity: [1, \"primaryOpacity\"],\n        secondaryOpacity: [1, \"secondaryOpacity\"],\n        primaryColor: [1, \"primaryColor\"],\n        secondaryColor: [1, \"secondaryColor\"]\n      },\n      features: [i0.ɵɵInheritDefinitionFeature],\n      decls: 0,\n      vars: 0,\n      template: function FaDuotoneIconComponent_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaDuotoneIconComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Warns if parent component not existing.\n */\nconst faWarnIfParentNotExist = (parent, parentName, childName) => {\n  if (!parent) {\n    throw new Error(`${childName} should be used as child of ${parentName} only.`);\n  }\n};\n\n/**\n * Fontawesome layers.\n */\nlet FaLayersComponent = /*#__PURE__*/(() => {\n  class FaLayersComponent {\n    size = input();\n    fixedWidth = input();\n    faFw = computed(() => {\n      const fixedWidth = this.fixedWidth();\n      return typeof fixedWidth === 'boolean' ? fixedWidth : this.config.fixedWidth;\n    });\n    classes = computed(() => {\n      const sizeValue = this.size();\n      const sizeClass = sizeValue ? {\n        [`fa-${sizeValue}`]: true\n      } : {};\n      return {\n        ...sizeClass,\n        'fa-fw': this.faFw(),\n        'fa-layers': true\n      };\n    });\n    document = inject(DOCUMENT);\n    config = inject(FaConfig);\n    ngOnInit() {\n      ensureCss(this.document, this.config);\n    }\n    static ɵfac = function FaLayersComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaLayersComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaLayersComponent,\n      selectors: [[\"fa-layers\"]],\n      hostVars: 2,\n      hostBindings: function FaLayersComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassMap(ctx.classes());\n        }\n      },\n      inputs: {\n        size: [1, \"size\"],\n        fixedWidth: [1, \"fixedWidth\"]\n      },\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function FaLayersComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaLayersComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaLayersCounterComponent = /*#__PURE__*/(() => {\n  class FaLayersCounterComponent {\n    content = input.required();\n    title = input();\n    position = input();\n    renderedHTML = computed(() => {\n      const params = this.buildParams();\n      return this.updateContent(params);\n    });\n    document = inject(DOCUMENT);\n    config = inject(FaConfig);\n    parent = inject(FaLayersComponent, {\n      optional: true\n    });\n    sanitizer = inject(DomSanitizer);\n    constructor() {\n      faWarnIfParentNotExist(this.parent, 'FaLayersComponent', this.constructor.name);\n    }\n    buildParams() {\n      const position = this.position();\n      return {\n        title: this.title(),\n        classes: position != null ? [`fa-layers-${position}`] : undefined\n      };\n    }\n    updateContent(params) {\n      ensureCss(this.document, this.config);\n      return this.sanitizer.bypassSecurityTrustHtml(counter(this.content() || '', params).html.join(''));\n    }\n    static ɵfac = function FaLayersCounterComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaLayersCounterComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaLayersCounterComponent,\n      selectors: [[\"fa-layers-counter\"]],\n      hostAttrs: [1, \"ng-fa-layers-counter\"],\n      hostVars: 1,\n      hostBindings: function FaLayersCounterComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"innerHTML\", ctx.renderedHTML(), i0.ɵɵsanitizeHtml);\n        }\n      },\n      inputs: {\n        content: [1, \"content\"],\n        title: [1, \"title\"],\n        position: [1, \"position\"]\n      },\n      decls: 0,\n      vars: 0,\n      template: function FaLayersCounterComponent_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaLayersCounterComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FaLayersTextComponent = /*#__PURE__*/(() => {\n  class FaLayersTextComponent {\n    content = input.required();\n    title = input();\n    flip = input();\n    size = input();\n    pull = input();\n    border = input();\n    inverse = input();\n    rotate = input();\n    fixedWidth = input();\n    transform = input();\n    renderedHTML = computed(() => {\n      const params = this.buildParams();\n      return this.updateContent(params);\n    });\n    document = inject(DOCUMENT);\n    config = inject(FaConfig);\n    parent = inject(FaLayersComponent, {\n      optional: true\n    });\n    sanitizer = inject(DomSanitizer);\n    constructor() {\n      faWarnIfParentNotExist(this.parent, 'FaLayersComponent', this.constructor.name);\n    }\n    /**\n     * Updating params by component props.\n     */\n    buildParams() {\n      const classOpts = {\n        flip: this.flip(),\n        border: this.border(),\n        inverse: this.inverse(),\n        size: this.size(),\n        pull: this.pull(),\n        rotate: this.rotate(),\n        fixedWidth: this.fixedWidth()\n      };\n      const transform = this.transform();\n      const parsedTransform = typeof transform === 'string' ? parse.transform(transform) : transform;\n      const styles = {};\n      if (classOpts.rotate != null && !isKnownRotateValue(classOpts.rotate)) {\n        styles['--fa-rotate-angle'] = `${classOpts.rotate}`;\n      }\n      return {\n        transform: parsedTransform,\n        classes: faClassList(classOpts),\n        title: this.title(),\n        styles\n      };\n    }\n    updateContent(params) {\n      ensureCss(this.document, this.config);\n      return this.sanitizer.bypassSecurityTrustHtml(text(this.content() || '', params).html.join('\\n'));\n    }\n    static ɵfac = function FaLayersTextComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FaLayersTextComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: FaLayersTextComponent,\n      selectors: [[\"fa-layers-text\"]],\n      hostAttrs: [1, \"ng-fa-layers-text\"],\n      hostVars: 1,\n      hostBindings: function FaLayersTextComponent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"innerHTML\", ctx.renderedHTML(), i0.ɵɵsanitizeHtml);\n        }\n      },\n      inputs: {\n        content: [1, \"content\"],\n        title: [1, \"title\"],\n        flip: [1, \"flip\"],\n        size: [1, \"size\"],\n        pull: [1, \"pull\"],\n        border: [1, \"border\"],\n        inverse: [1, \"inverse\"],\n        rotate: [1, \"rotate\"],\n        fixedWidth: [1, \"fixedWidth\"],\n        transform: [1, \"transform\"]\n      },\n      decls: 0,\n      vars: 0,\n      template: function FaLayersTextComponent_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return FaLayersTextComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FontAwesomeModule = /*#__PURE__*/(() => {\n  class FontAwesomeModule {\n    static ɵfac = function FontAwesomeModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FontAwesomeModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: FontAwesomeModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return FontAwesomeModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FaConfig, FaDuotoneIconComponent, FaIconComponent, FaIconLibrary, FaLayersComponent, FaLayersCounterComponent, FaLayersTextComponent, FaStackComponent, FaStackItemSizeDirective, FontAwesomeModule };\n//# sourceMappingURL=angular-fontawesome.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}